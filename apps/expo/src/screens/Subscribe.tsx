import { AntDesign } from "@expo/vector-icons";
import * as Device from "expo-device";
import * as Notifications from "expo-notifications";
import React, { useState } from "react";
import { ActivityIndicator, FlatList, Platform } from "react-native";
import Animated, { FadeIn, FadeOut } from "react-native-reanimated";
import ButtonContainer from "../components/ButtonContainer";
import ScreenLayout from "../components/ScreenLayout";
import SearchInput from "../components/SearchInput";
import {
  AlertText,
  PrimaryText,
  SecondaryText,
  SpecialText,
  specialTextColor,
  ThemedView,
} from "../components/Themed";
import { trpc } from "../components/TRPCProvider";
import { useTrackParallelMutations } from "../hooks/use-track-parallel-mutations";
import tw from "../tailwind";

export const Subscribe = () => {
  const {
    data: subscriptions,
    refetch,
    isSuccess: subscriptionsFetched,
    isLoading: subsLoading,
  } = trpc.subscription.byUserId.useQuery();

  const { data: devices, isSuccess: devicesFetched } =
    trpc.device.byUserId.useQuery();

  const [searchFilter, setSearchFilter] = useState<string>();

  const {
    data: pitchersFromSearch,
    isSuccess,
    isLoading,
    isInitialLoading,
    isError,
  } = trpc.pitcher.byNameSearch.useQuery(searchFilter?.split(" ") || [], {
    enabled: !!searchFilter && subscriptionsFetched && devicesFetched,
  });

  const utils = trpc.useContext();

  const pitchers = pitchersFromSearch?.map((pitcher) => ({
    ...pitcher,
    subscription:
      subscriptions?.find((sub) => sub.pitcherId === pitcher.id) || undefined,
  }));

  const { mutate: registerDevice } = trpc.device.create.useMutation({
    onSettled: () => utils.device.byUserId.invalidate(),
  });

  const mutationTracker = useTrackParallelMutations();

  const { mutate: subscribe } = trpc.subscription.create.useMutation({
    onMutate: ({ pitcherId }) => {
      mutationTracker.startOne();
      const previousSubscriptions = utils.subscription.byUserId.getData();
      utils.subscription.byUserId.setData((old) => {
        if (old) {
          return [
            ...old,
            // Optimistically add a new subscription with some dummy data.
            // Ths dummy data will be replaced with ids generated by the
            // database once the mutation completes.
            {
              id: new Date().valueOf(),
              enabled: true,
              pitcherId: pitcherId,
              userId: "temporary",
              pitcher: { id: pitcherId, name: "foo", teamId: 123 },
            },
          ];
        }
      });
      return { previousSubscriptions };
    },
    onError: (err, newSubscription, context) => {
      utils.subscription.byUserId.setData(context?.previousSubscriptions);
    },
    onSettled: () => {
      mutationTracker.endOne();
      if (mutationTracker.allEnded()) {
        utils.subscription.byUserId.invalidate();
        utils.pitcher.byNameSearch.invalidate();
      }
    },
  });

  const { mutate: unsubscribe } = trpc.subscription.delete.useMutation({
    onMutate: (subscriptionId) => {
      mutationTracker.startOne();
      const previousSubscriptions = utils.subscription.byUserId.getData();
      utils.subscription.byUserId.setData((old) =>
        old?.map((s) =>
          s.id !== subscriptionId ? s : { ...s, userId: "temporary" }
        )
      );
      return { previousSubscriptions };
    },
    onError: (err, newSubscription, context) => {
      utils.subscription.byUserId.setData(context?.previousSubscriptions);
    },
    onSettled: () => {
      mutationTracker.endOne();
      if (mutationTracker.allEnded()) {
        utils.subscription.byUserId.invalidate();
        utils.pitcher.byNameSearch.invalidate();
      }
    },
  });

  return (
    <ScreenLayout>
      <FlatList
        contentContainerStyle={tw`px-3 pt-9 pb-12`}
        data={pitchers}
        keyboardShouldPersistTaps="handled"
        renderItem={({ item: pitcher, index }) => (
          <Animated.View entering={FadeIn} exiting={FadeOut}>
            <ThemedView
              style={tw.style(
                "border-b-2",
                index === 0 ? "rounded-t-xl" : undefined,
                index + 1 === pitchers?.length
                  ? "border-b-0 rounded-b-xl mb-6"
                  : undefined
              )}
            >
              <PrimaryText style={tw`flex-1 pr-2.5`} numberOfLines={1}>
                {pitcher.name}
              </PrimaryText>
              {pitcher.subscription &&
                pitcher.subscription.userId === "temporary" && (
                  <ActivityIndicator size="small" />
                )}
              {pitcher.subscription &&
                pitcher.subscription.userId !== "temporary" && (
                  <ButtonContainer
                    style={tw`absolute right-0 py-4 pl-4 pr-3`}
                    onPress={() => {
                      unsubscribe(pitcher.subscription!.id);
                    }}
                    // disabled={!mutationTracker.allEnded() || isLoading}
                  >
                    <AlertText>
                      <AntDesign name="minuscircle" size={20} />
                    </AlertText>
                  </ButtonContainer>
                )}
              {!pitcher.subscription && (
                <ButtonContainer
                  style={tw`absolute right-0 py-4 pl-4 pr-3`}
                  // disabled={!mutationTracker.allEnded() || isLoading}
                  onPress={async () => {
                    const pushToken = await registerForPushNotifications();
                    if (pushToken) {
                      if (
                        devices &&
                        !devices.some(
                          (device) => device.pushToken === pushToken
                        )
                      ) {
                        registerDevice({ token: pushToken });
                      }
                      subscribe({
                        pitcherId: pitcher.id,
                      });
                    } else {
                      alert(
                        "To subscribe you must allow Probable Pitcher to send push notifications. Check the application settings."
                      );
                    }
                  }}
                >
                  <SpecialText>
                    <AntDesign name="pluscircle" size={20} />
                  </SpecialText>
                </ButtonContainer>
              )}
            </ThemedView>
          </Animated.View>
        )}
        ListHeaderComponent={
          <SearchInput
            onChange={(text) => {
              setSearchFilter(text);
            }}
          />
        }
        ListEmptyComponent={
          <>
            {isSuccess && (
              <Animated.View entering={FadeIn.delay(150)} exiting={FadeOut}>
                <SecondaryText
                  style={tw`mb-9 mx-3 text-sm`}
                  accessibilityRole="summary"
                >
                  No pitchers found. Try changing your search.
                </SecondaryText>
              </Animated.View>
            )}
            {isInitialLoading ? (
              <Animated.View entering={FadeIn} exiting={FadeOut}>
                <ActivityIndicator
                  size="large"
                  color={String(tw.style(specialTextColor).color)}
                />
              </Animated.View>
            ) : (
              !isSuccess && (
                <Animated.View entering={FadeIn} exiting={FadeOut}>
                  <SecondaryText
                    style={tw`mb-9 mx-3 text-sm`}
                    accessibilityRole="summary"
                  >
                    Enter a players name to perform a search.
                  </SecondaryText>
                </Animated.View>
              )
            )}
            {isError && (
              <Animated.View entering={FadeIn.delay(150)} exiting={FadeOut}>
                <AlertText
                  style={tw`mb-9 mx-3 text-sm`}
                  accessibilityRole="alert"
                >
                  An error occurred while performing your search. Please try
                  again later.
                </AlertText>
              </Animated.View>
            )}
          </>
        }
      />
    </ScreenLayout>
  );
};

const registerForPushNotifications = async () => {
  let token;
  if (Device.isDevice) {
    const { status: existingStatus } =
      await Notifications.getPermissionsAsync();
    let finalStatus = existingStatus;
    if (existingStatus !== "granted") {
      const { status } = await Notifications.requestPermissionsAsync();
      finalStatus = status;
    }
    if (finalStatus !== "granted") {
      alert("Failed to get push token for push notification!");
      return;
    }
    token = (await Notifications.getExpoPushTokenAsync()).data;
  } else {
    alert("Must use physical device for Push Notifications");
  }

  if (Platform.OS === "android") {
    Notifications.setNotificationChannelAsync("default", {
      name: "default",
      importance: Notifications.AndroidImportance.MAX,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: "#FF231F7C",
    });
  }

  return token;
};
